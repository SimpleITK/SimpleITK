/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at sitkImageFilterTemplate.cxx.in to make changes.
 */

#include "itkImage.h"
#include "itkVectorImage.h"
#include "itkLabelMap.h"
#include "itkLabelObject.h"
#include "itkNumericTraits.h"
#include "itkNumericTraitsVariableLengthVectorPixel.h"
#include "itkVectorIndexSelectionCastImageFilter.h"
#include "itkImageToVectorImageFilter.h"


#include "sitk${name}ImageFilter.h"
#include "itk${name}ImageFilter.h"
$(if include_files and #include_files > 0 then
OUT = [[// Additional include files
$(for i=1,#include_files do OUT = OUT .. '#include "' .. include_files[i] .. '"' if i < #include_files then OUT = OUT .. '\n' end end)
// Done with additional include files]]
end)

namespace itk {
namespace simple {

//-----------------------------------------------------------------------------

//
// Default constructor that initializes parameters
//
${name}ImageFilter::${name}ImageFilter ()
{
$(foreach members
$(if default then
OUT = [[
  this->m_${name} = ${default};]] end)
)
  this->m_MemberFactory.reset( new detail::MemberFunctionFactory<MemberFunctionType>( this ) );

  this->m_MemberFactory->RegisterMemberFunctions< PixelIDTypeList, 3 > ();
  this->m_MemberFactory->RegisterMemberFunctions< PixelIDTypeList, 2 > ();

  $(if vector_pixel_types_by_component then
    OUT=[[  typedef ${vector_pixel_types_by_component} VectorByComponentsPixelIDTypeList;
  typedef detail::ExecuteInternalVectorImageAddressor<MemberFunctionType> VectorAddressorType;
  this->m_MemberFactory->RegisterMemberFunctions< VectorByComponentsPixelIDTypeList, 3, VectorAddressorType> ();
  this->m_MemberFactory->RegisterMemberFunctions< VectorByComponentsPixelIDTypeList, 2, VectorAddressorType> ();]]
  end)

}

//
// ToString
//
std::string ${name}ImageFilter::ToString() const
{
  std::ostringstream out;
  out << "itk::simple::${name}ImageFilter\n";
$(foreach members
$(if dim_vec and dim_vec == 1 then
OUT = '  out << "  ${name}: ";\
  printStdVector(this->m_${name}, out);\
  out << std::endl;'
elseif (not no_print) or (not no_print == 1) then
OUT = '  out << "  ${name}: " << this->m_${name} << std::endl;'
end)
)
  return out.str();
}

//
// Execute
//$(if members and #members > 0 then
OUT = [[

Image ${name}ImageFilter::Execute ( const Image & image1$(if number_of_inputs==2 then OUT=', const Image& image2' end)$(foreach members ,
  ${type} in${name}) )
{
$(foreach members
$(if (not no_set_method) or (no_set_method == 0) then
OUT = '  this->Set${name} ( in${name} );'
end)
)
  return this->Execute ( image1 $(if number_of_inputs==2 then OUT=', image2' end) );
}
]]
end)
Image ${name}ImageFilter::Execute ( const Image & image1$(if number_of_inputs==2 then OUT=[[, const Image& image2]] end) )
{

  PixelIDValueType type = image1.GetPixelIDValue();
  unsigned int dimension = image1.GetDimension();$(if number_of_inputs and number_of_inputs == 2 then
OUT=[[


  // todo need better error handling and potential type conversion
  if ( type != image2.GetPixelIDValue() ||
       dimension != image2.GetDimension() ||
       image1.GetWidth() != image2.GetWidth() ||
       image1.GetHeight() != image2.GetHeight() ||
       image1.GetDepth() != image2.GetDepth() )
    {
      sitkExceptionMacro ( "Both images for ${name}ImageFilter don't match type or dimension!" );
    }]] end)

  return this->m_MemberFactory->GetMemberFunction( type, dimension )( image1 $(if number_of_inputs==2 then OUT=[[, image2]] end) );
}

//-----------------------------------------------------------------------------

//
// ExecuteInternal
//
template <class TImageType>
Image ${name}ImageFilter::ExecuteInternal ( const Image& inImage1 $(if number_of_inputs==2 then OUT=[[, const Image& inImage2]] end) )
{
  // Define the input and output image types
  typedef TImageType     InputImageType;
  $(if output_pixel_type then
  OUT=[[// Define output image type
  typedef itk::Image< ${output_pixel_type}, InputImageType::ImageDimension > OutputImageType;]]
  elseif real_type_output==1 then
  OUT=[[// Real output type
  typedef itk::Image< typename itk::NumericTraits< typename InputImageType::PixelType >::RealType,
    InputImageType::ImageDimension > OutputImageType;]]
  else
  OUT=[[typedef InputImageType OutputImageType;]]
  end)

  // Get the a pointer to the ITK image contained in image1
  typename InputImageType::ConstPointer image1 =
    dynamic_cast <const InputImageType*> ( inImage1.GetImageBase() );

  // Check that ITK image pointer was properly retrieved
  if ( image1.IsNull() )
    {
    sitkExceptionMacro( "Unexpected template dispatch error!" );
    }$(if number_of_inputs == 2 then
OUT=[[


  // Get the a pointer to the ITK image contained in image2
  typename InputImageType::ConstPointer image2 =
  dynamic_cast <const InputImageType*> ( inImage2.GetImageBase() );

  // Check that ITK image pointer was properly retrieved
  if ( image2.IsNull() )
    {
    sitkExceptionMacro( "Unexpected template dispatch error!" );
    }]]
end)

  $(if filter_type then
    OUT=[[typedef ${filter_type} FilterType;]]
  else
    OUT=[[typedef itk::${name}ImageFilter<InputImageType,]]
         if number_of_inputs == 2 then
           OUT=OUT .. ' InputImageType,'
           end
         if additional_template_types then
         OUT=OUT .. [[ $(foreach additional_template_types ${type},) ]]
         end
     OUT=OUT .. [[  OutputImageType> FilterType;]]
  end)
  // Set up the ITK filter
  typename FilterType::Pointer filter = FilterType::New();

$(if number_of_inputs == 2 then
OUT=[[
  filter->SetInput( 0, image1 );
  filter->SetInput( 1, image2 );
]]
else
OUT=[[
  filter->SetInput( image1 );
]]
end)$(foreach members
$(if custom_itk_cast then
OUT = '  ${custom_itk_cast}'
elseif dim_vec and dim_vec == 1 then
OUT = [[  ${itk_type} itkVec${name};
  for (unsigned int i = 0; i < inImage1->GetDimension(); ++i)
    {
    itkVec${name}[i] = this->Get${name}()[i];
    }
  filter->Set${name}( itkVec${name} );]]
elseif(not no_set_method) or (no_set_method == 0) then
OUT = '  filter->Set${name} ( this->m_${name} );'
end)
)
  // Run the ITK filter and return the output as a SimpleITK image
  filter->Update();

  return Image( filter->GetOutput() );
}


//-----------------------------------------------------------------------------

//
// Dispatched methods to call ExecuteInternal on each component of the VectorImage
//
$(if vector_pixel_types_by_component then
OUT=[[template <class TImageType> Image
${name}ImageFilter::ExecuteInternalVectorImage ( const Image& inImage1 )
{
  // Define the input and output image types
  typedef TImageType                                                         InputImageType;
  typedef typename InputImageType::InternalPixelType                         ComponentType;
  typedef typename itk::Image<ComponentType, InputImageType::ImageDimension> ComponentImageType;

  // fix me
  typedef InputImageType OutputImageType;

  // Get the a pointer to the ITK image contained in image1
  typename InputImageType::ConstPointer image1 =
    dynamic_cast <const InputImageType*> ( inImage1.GetImageBase() );

  // Check that ITK image pointer was properly retrieved
  if ( image1.IsNull() )
    {
    sitkExceptionMacro( "Unexpected template dispatch error!" );
    }

  typedef itk::VectorIndexSelectionCastImageFilter< InputImageType, OutputImageType > ComponentExtratorType;
  typename ComponentExtratorType::Pointer extractor = ComponentExtratorType::New();
  extractor->SetInput( image1 );

  typedef itk::ImageToVectorImageFilter<ComponentImageType> ToVectorFilterType;
  typename ToVectorFilterType::Pointer toVector = ToVectorFilterType::New();

  unsigned int numComps = image1->GetNumberOfComponentsPerPixel();
  for ( unsigned int i = 0; i < numComps; ++i )
    {
    extractor->SetIndex( i );
    extractor->Update();

    Image tmp = this->ExecuteInternal<ComponentImageType>( Image( extractor->GetOutput() ) );

    typename ComponentImageType::ConstPointer tempITKImage =
      dynamic_cast <const ComponentImageType*> ( tmp.GetImageBase() );

    toVector->SetNthInput( i, tempITKImage );
    }

  toVector->Update();

  return Image( toVector->GetOutput() );
}
]]
end)

//-----------------------------------------------------------------------------

//
// Function to run the Execute method of this filter
//
Image ${name} ( const Image& imageA$(if number_of_inputs == 2 then OUT=', const Image& imageB' end)$(when members $(foreach members ,
  ${type} in${name})) )
{
  ${name}ImageFilter filter;
  return filter.Execute ( imageA$(if number_of_inputs == 2 then OUT=', imageB' end)$(when members $(foreach members , in${name})) );
}

} // end namespace simple
} // end namespace itk
