{
  "name" : "N4BiasFieldCorrectionImageFilter",
  "template_code_filename" : "DualImageFilter",
  "template_test_filename" : "ImageFilter",
  "number_of_inputs" : 2,
  "doc" : "Some global documentation",
  "pixel_types" : "RealPixelIDTypeList",
  "pixel_types2" : "IntegerPixelIDTypeList",
  "custom_set_input" : "filter->SetInput1( image1 ); filter->SetInput2( image2 );",
  "members" : [
    {
      "name" : "ConvergenceThreshold",
      "type" : "double",
      "default" : "0.001",
      "doc" : "",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the convergence threshold. Convergence is determined by the coefficient of variation of the difference image between the current bias field estimate and the previous estimate. If this value is less than the specified threshold, the algorithm proceeds to the next fitting level or terminates if it is at the last level.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the convergence threshold. Convergence is determined by the coefficient of variation of the difference image between the current bias field estimate and the previous estimate. If this value is less than the specified threshold, the algorithm proceeds to the next fitting level or terminates if it is at the last level.\n"
    },
    {
      "name" : "MaximumNumberOfIterations",
      "type" : "std::vector<uint32_t>",
      "default" : "std::vector<uint32_t>(4,50)",
      "custom_itk_cast" : "typename FilterType::VariableSizeArrayType maximumNumberOfIterations( this->m_MaximumNumberOfIterations.size() );\n  for( unsigned int i = 0; i < this->m_MaximumNumberOfIterations.size(); ++i)\n    maximumNumberOfIterations[i] = this->m_MaximumNumberOfIterations[i];\n  filter->SetMaximumNumberOfIterations( maximumNumberOfIterations );\n  filter->SetNumberOfFittingLevels( this->m_MaximumNumberOfIterations.size() );",
      "doc" : "\todo this variable needs to be printed",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the maximum number of iterations specified at each fitting level. Default = 50.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the maximum number of iterations specified at each fitting level. Default = 50.\n"
    },
    {
      "name" : "BiasFieldFullWidthAtHalfMaximum",
      "type" : "double",
      "default" : "0.15",
      "doc" : "",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the full width at half maximum parameter characterizing the width of the Gaussian deconvolution. Default = 0.15.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the full width at half maximum parameter characterizing the width of the Gaussian deconvolution. Default = 0.15.\n"
    },
    {
      "name" : "WienerFilterNoise",
      "type" : "double",
      "default" : "0.01",
      "doc" : "",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the noise estimate defining the Wiener filter. Default = 0.01.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the noise estimate defining the Wiener filter. Default = 0.01.\n"
    },
    {
      "name" : "NumberOfHistogramBins",
      "type" : "uint32_t",
      "default" : "200u",
      "doc" : "",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set number of bins defining the log input intensity histogram. Default = 200.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get number of bins defining the log input intensity histogram. Default = 200.\n"
    },
    {
      "name" : "NumberOfControlPoints",
      "type" : "std::vector<uint32_t>",
      "default" : "std::vector<uint32_t>(3, 4)",
      "doc" : "",
      "dim_vec" : 1,
      "itk_type" : "typename FilterType::ArrayType",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the control point grid size defining the B-spline estimate of the scalar bias field. In each dimension, the B-spline mesh size is equal to the number of control points in that dimension minus the spline order. Default = 4 control points in each dimension for a mesh size of 1 in each dimension.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the control point grid size defining the B-spline estimate of the scalar bias field. In each dimension, the B-spline mesh size is equal to the number of control points in that dimension minus the spline order. Default = 4 control points in each dimension for a mesh size of 1 in each dimension.\n"
    },
    {
      "name" : "SplineOrder",
      "type" : "uint32_t",
      "default" : "3u",
      "doc" : "",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the spline order defining the bias field estimate. Default = 3.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the spline order defining the bias field estimate. Default = 3.\n"
    }
  ],
  "tests" : [
    {
      "tag" : "defaults",
      "description" : "using default parameters in 2D",
      "settings" : [],
      "tolerance" : "0.01",
      "inputs" : [
        "Input/cthead1-Float.mha",
        "Input/2th_cthead1.mha"
      ]
    }
  ],
  "briefdescription" : "Implementation of the N4 bias field correction algorithm.\n",
  "detaileddescription" : "The nonparametric nonuniform intensity normalization (N3) algorithm, as introduced by Sled et al. in 1998 is a method for correcting nonuniformity associated with MR images. The algorithm assumes a simple parametric model (Gaussian) for the bias field and does not require tissue class segmentation. In addition, there are only a couple of parameters to tune with the default values performing quite well. N3 has been publicly available as a set of perl scripts (http://www.bic.mni.mcgill.ca/ServicesSoftwareAdvancedImageProcessingTools/HomePage)\nThe N4 algorithm, encapsulated with this class, is a variation of the original N3 algorithm with the additional benefits of an improved B-spline fitting routine which allows for multiple resolutions to be used during the correction process. We also modify the iterative update component of algorithm such that the residual bias field is continually updated\nNotes for the user:\\li Since much of the image manipulation is done in the log space of the intensities, input images with negative and small values (< 1) can produce poor results.\n\\li The original authors recommend performing the bias field correction on a downsampled version of the original image.\n\\li A binary mask or a weighted image can be supplied. If a binary mask is specified, those voxels in the input image which correspond to the voxels in the mask image with a value equal to m_MaskLabel, are used to estimate the bias field. If a confidence image is specified, the input voxels are weighted in the b-spline fitting routine according to the confidence voxel values.\n\\li The filter returns the corrected image. If the bias field is wanted, one can reconstruct it using the class itkBSplineControlPointImageFilter. See the IJ article and the test file for an example.\n\\li The 'Z' parameter in Sled's 1998 paper is the square root of the class variable 'm_WienerFilterNoise'.\n\nThe basic algorithm iterates between sharpening the intensity histogram of the corrected input image and spatially smoothing those results with a B-spline scalar field estimate of the bias field.\n\\author Nicholas J. Tustison\nContributed by Nicholas J. Tustison, James C. Gee in the Insight Journal paper:http://hdl.handle.net/10380/3053\n\\par REFERENCE\nJ.G. Sled, A.P. Zijdenbos and A.C. Evans. \"A Nonparametric Method for\nAutomatic Correction of Intensity Nonuniformity in  Data\" IEEE Transactions on Medical Imaging, Vol 17, No 1. Feb 1998.\nN.J. Tustison, B.B. Avants, P.A. Cook, Y. Zheng, A. Egan, P.A. Yushkevich, and J.C. Gee. \"N4ITK:  Improved N3 Bias Correction\" IEEE Transactions on Medical Imaging, 29(6):1310-1320, June 2010.\n"
}
