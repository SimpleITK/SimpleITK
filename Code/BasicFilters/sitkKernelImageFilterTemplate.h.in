#ifndef __sitk${name}ImageFilter_h
#define __sitk${name}ImageFilter_h

#include <memory>

#include "sitkDualImageFilter.h"
$(if include_files and #include_files > 0 then
OUT = [[// Additional include files
$(for i=1,#include_files do OUT = OUT .. '#include "' .. include_files[i] .. '"' if i < #include_files then OUT = OUT .. '\n' end end)
// Done with additional include files]]
end)

namespace itk {
  namespace simple {

    /** \class ${name}ImageFilter
     *
     * ${doc}
     */
    class ${name}ImageFilter : public $(if number_of_inputs == 2 then OUT=[[DualImageFilter]] else OUT=[[ImageFilter]] end) {
    public:
      typedef ${name}ImageFilter Self;

      /** Default Constructor that takes no arguments and initializes
       * default parameters */
      ${name}ImageFilter();

      /** Kernel type enumeration */
    typedef enum{Annulus, Ball, Box, Cross} KernelType;
$(if public_declarations then
      OUT=[[
      /** Custom public declarations */
      ${public_declarations}
]]end)
$(foreach members
$(if (not no_set_method) or (no_set_method == 0) then
      OUT = '\
      /** Set ${name} */\
      Self& Set${name} ( ${type} t ) { this->m_${name} = t; return *this; }'
  if type == "bool" then
      OUT = OUT .. '\
\
      /** Set the value of ${name} to true or false respectfully. */\
      Self& ${name}On() { return this->Set${name}(true); }\
      Self& ${name}Off() { return this->Set${name}(false); }'
  end
end)
$(if (not no_get_method) or (no_get_method == 0) then
      OUT = '\
      /** Get ${name} */\
      ${type} Get${name}() { return this->m_${name}; }'
end)
)
      /** Kernel radius as a scale for isotropic structures */
      Self& SetKernelRadius(uint32_t r);

      /** Set/Get the radius of the kernel structuring element as a
       * vector.
       *
       * If the dimension of the image is greater then the length of
       * r, then the radius will be padded. If it is less the r will
       * be truncated.
       */
      Self& SetKernelRadius(const std::vector<uint32_t>  &r );
      std::vector<uint32_t> GetKernelRadius() const;

      /** Set/Get the kernel or structuring elemenent used for the
       * morphology */
      Self& SetKernelType(KernelType t);
      KernelType GetKernelType() const;

      /** Print ourselves out */
      std::string ToString() const;

      /** Execute the filter on the input image$(if number_of_inputs == 2 then OUT=[[s]]end) */
      Image* Execute ( Image* $(if number_of_inputs == 2 then OUT=[[, Image*]] end) );$(if members and #members > 0 then
OUT=[[


      /** Execute the filter on the input image$(if number_of_inputs == 2 then OUT='s'end) with the given parameters */
      Image* Execute ( Image*$(if number_of_inputs == 2 then OUT=', Image*' end)$(foreach members ,
        ${type} in${name}) );]]end)$(if custom_methods and #custom_methods > 0 then
OUT = [[


$(foreach custom_methods
      /** ${doc} */
      ${return_type} ${name}( $(foreach parameters ${type} ${var_name}$(if last == 0 then OUT=', ' end)) )
        {
        ${body}
        };
)]]end)

    private:

$(if number_of_inputs == 2 then
OUT=[[
      /** Setup for member function dispatching */
      typedef Image* (Self::*MemberFunctionType)( Image*, Image* );
      template <class TImageType> Image* ExecuteInternal ( Image* image1, Image* image2 );
      friend struct detail::MemberFunctionAddressor<MemberFunctionType>;
      std::auto_ptr<detail::MemberFunctionFactory<MemberFunctionType> > m_MemberFactory;
]]
else
OUT=[[
      /** Setup for member function dispatching */
      typedef Image* (Self::*MemberFunctionType)( Image* );
      template <class TImageType> Image* ExecuteInternal ( Image* image );
      template <class TImageType> Image* ExecuteInternalVectorImage ( Image* image );
      friend struct detail::MemberFunctionAddressor<MemberFunctionType>;
      std::auto_ptr<detail::MemberFunctionFactory<MemberFunctionType> > m_MemberFactory;
]]end)
$(foreach members
      /* ${doc} */
      ${type} m_${name};
)
// SWIG does not appear to process private classes correctly
#ifndef SWIG

  /** An addressor of ExecuteInternalCast to be utilized with
   * registering member functions with the factory.
   */
  template < class TMemberFunctionPointer >
  struct VectorAddressor
  {
    typedef typename ::detail::FunctionTraits<TMemberFunctionPointer>::ClassType ObjectType;

    template< typename TImageType >
    TMemberFunctionPointer operator() ( void ) const
    {
      return &ObjectType::template ExecuteInternalVectorImage< TImageType >;
    }
  };
#endif

      /** boolean value to indicate if the vector or scalar should be
       *  used for the radius of the kernel */
      bool m_BVectorRadius;

      /* Kernel Radius as a vector */
      std::vector<uint32_t> m_VectorKernelRadius;

      /** Isotropic Kernel Radius */
      uint32_t m_KernelRadius;

      /** KernelType */
      KernelType m_KernelType;
    };


    /**
     * itk::simple::${name}ImageFilter Functional Interface
     *
     * This function directly calls the execute method of ${name}ImageFilter
     * in order to support a fully functional API
     */
  Image* ${name} ( Image*$(if number_of_inputs == 2 then OUT=', Image*' end),
                   uint32_t inRadius = 1, ${name}ImageFilter::KernelType inKernel =${name}ImageFilter::Ball
                   $(when members $(foreach members , ${type} in${name} = ${default})) );

 /**
     * itk::simple::${name}ImageFilter Functional Interface
     *
     * This function directly calls the execute method of ${name}ImageFilter
     * in order to support a fully functional API
     */
  Image* ${name} ( Image*$(if number_of_inputs == 2 then OUT=', Image*' end),
                   const std::vector<uint32_t> inVectorRadius, ${name}ImageFilter::KernelType inKernel =${name}ImageFilter::Ball
                   $(when members $(foreach members , ${type} in${name} = ${default})) );
  }
}
#endif
