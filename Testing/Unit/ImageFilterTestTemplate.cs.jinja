/*=========================================================================
 *
 *  Copyright NumFOCUS
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at ImageFilterTestTemplate.cs.jinja for the template.
 */

using System;
using System.Collections.Generic;
using itk.simple;

// This is C# code to test {{ name }}
class {{ name }}Test {

  static int Main(string[] args) {

    try {
        int num_inputs = {{ number_of_inputs | default(1) }};

        // Check the command line arguments
        if ( args.Length < num_inputs + 1 ) {
            Console.WriteLine("Usage: ${name} tag <input(s)> output");
            return 1;
        }

        String tag = args[0];

        // Instantiate objects
        ImageFileReader reader = new ImageFileReader();
        {{ name }} filter = new {{ name }}();
        List<Image> inputs = new List<Image>();
{% if tests|length == 0 %}
        // No tests defined => exit with error code
        Console.WriteLine("No tests defined!");
        return 1;
{% endif %}


    // Run each test
{% for test in tests %}
    if (tag.Equals("{{ test.tag }}")) {

        // Read image(s)
        for (int i = 1; i < args.Length - 1; i++) {
            reader.SetFileName(args[i]);
            inputs.Add(reader.Execute());
        }

{%- if test.inputA_cast %}
        CastImageFilter casterA = new CastImageFilter();
        casterA.SetOutputPixelType(PixelIDValueEnum.{{ test.inputA_cast }});
        inputs[0] = casterA.Execute(inputs[0]);
{% endif %}

{%- if test.inputB_cast %}
        CastImageFilter casterB = new CastImageFilter();
        casterB.SetOutputPixelType(PixelIDValueEnum.{{ test.inputB_cast }});
        inputs[1] = casterB.Execute(inputs[1]);
{% endif %}

{% for setting in test.settings -%}
{% if setting.parameter == "SeedList" %}
        filter.ClearSeeds();
{% for value in setting.value %}
        {
            VectorUInt32 idx = new VectorUInt32(new uint[] {{ value }});
            filter.AddSeed(idx);
        }
{%- endfor %}
{% elif setting.parameter == "TrialPoints" %}
        filter.ClearTrialPoints();
{% for value in setting.value %}
        {
            VectorUInt32 idx = new VectorUInt32(new uint[] {{ value }});
            filter.AddTrialPoint(idx);
        }
{%- endfor %}
{% elif setting.point_vec %}
    filter.Clear{{ setting.parameter }}();
 {% for value in setting.value %}
    {
        VectorUInt32 pt = new VectorUInt32(new uint[] {{ value }});
        filter.Add{{ setting.parameter | regex_replace('s([0-9]?)$', '\\1') }}(pt);
    }
{%- endfor %}
{%- elif setting.dim_vec %}
    {
        {%- if setting.type == "bool" -%}
        {%- set vector_type = "VectorBool" -%}
        {%- set vector_value_type = "bool" -%}
        {%- elif setting.type == "unsigned int" -%}
        {%- set vector_type = "VectorUInt32" -%}
        {%- set vector_value_type = "uint" -%}
        {%- elif setting.type == "int" -%}
        {%- set vector_type = "VectorInt32" -%}
        {%- set vector_value_type = "int" -%}
        {%- elif setting.type == "unsigned long" -%}
        {%- set vector_type = "VectorULong" -%}
        {%- set vector_value_type = "ulong" -%}
        {%- elif setting.type == "long" -%}
        {%- set vector_type = "VectorLong" -%}
        {%- set vector_value_type = "long" -%}
        {%- elif setting.type == "unsigned short" -%}
        {%- set vector_type = "VectorUShort" -%}
        {%- set vector_value_type = "ushort" -%}
        {%- elif setting.type == "short" -%}
        {%- set vector_type = "VectorShort" -%}
        {%- set vector_value_type = "short" -%}
        {%- elif setting.type == "float" -%}
        {%- set vector_type = "VectorFloat" -%}
        {%- set vector_value_type = "float" -%}
        {%- elif setting.type == "double" -%}
        {%- set vector_type = "VectorDouble" -%}
        {%- set vector_value_type = "double" -%}
        {%- elif setting.type == "uint8_t" -%}
        {%- set vector_type = "VectorUInt8" -%}
        {%- set vector_value_type = "byte" -%}
        {%- elif setting.type == "uint16_t" -%}
        {%- set vector_type = "VectorUInt16" -%}
        {%- set vector_value_type = "ushort" -%}
        {%- elif setting.type == "uint32_t" -%}
        {%- set vector_type = "VectorUInt32" -%}
        {%- set vector_value_type = "uint" -%}
        {%- elif setting.type == "uint64_t" -%}
        {%- set vector_type = "VectorUInt64" -%}
        {%- set vector_value_type = "ulong" -%}
        {%- elif setting.type == "int8_t" -%}
        {%- set vector_type = "VectorInt8" -%}
        {%- set vector_value_type = "sbyte" -%}
        {%- elif setting.type == "int16_t" -%}
        {%- set vector_type = "VectorInt16" -%}
        {%- set vector_value_type = "short" -%}
        {%- elif setting.type == "int32_t" -%}
        {%- set vector_type = "VectorInt32" -%}
        {%- set vector_value_type = "int" -%}
        {%- elif setting.type == "int64_t" -%}
        {%- set vector_type = "VectorInt64" -%}
        {%- set vector_value_type = "long" -%}
        {%- endif -%}
        {{ vector_type }} idx = new {{ vector_type }}(new {{ vector_value_type }}[] { {{ setting.value | join(', ') }} });
        filter.Set{{ setting.parameter }}(idx);
    }
{% else %}
    filter.Set{{ setting.parameter }}({{ setting.csharp_value if setting.csharp_value else setting.value }});
{% endif %}
{%- endfor %}

    // Run the filter
    {% if not no_return_image %}Image output = {% endif %}filter.Execute({% for inum in range(test.inputs|length) %}inputs[{{ inum }}]{% if not loop.last %}, {% endif %}{% endfor %});

    {% if not no_return_image %}
    PixelIDValueEnum[] labelIDs = { PixelIDValueEnum.sitkLabelUInt8, PixelIDValueEnum.sitkLabelUInt16, PixelIDValueEnum.sitkLabelUInt32, PixelIDValueEnum.sitkLabelUInt64 };
    if (Array.IndexOf(labelIDs, output.GetPixelID()) != -1) {
        LabelMapToLabelImageFilter toImage = new LabelMapToLabelImageFilter();
        output = toImage.Execute(output);
    }

    // Write output
    ImageFileWriter writer = new ImageFileWriter();
    writer.UseCompressionOn();
    writer.SetFileName(args[args.Length - 1]);
    writer.Execute(output);
    {% endif %}
}
{% endfor %}
    } catch (Exception ex) {
        Console.WriteLine( "ERROR: " + ex.ToString() );
        return 1;
    }
    return 0;
  }
}
