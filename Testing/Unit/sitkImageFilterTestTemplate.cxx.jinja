/*=========================================================================
*
*  Copyright NumFOCUS
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
/*
* WARNING: DO NOT EDIT THIS FILE!
* THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
* Please look at sitkImageFilterTestTemplate.cxx.jinja to make changes.
*/

#include <SimpleITKTestHarness.h>

#include <sitk{{ name }}.h>
#include <sitkImageFileReader.h>
#include <sitkImageFileWriter.h>
#include <sitkHashImageFilter.h>
#include <sitkCastImageFilter.h>
#include <sitkConditional.h>
#include <sitkVersion.h>

#include <array>

[[maybe_unused]] static bool isLabelType(const itk::simple::Image &img)
{
 static const std::array<itk::simple::PixelIDValueEnum, 4> labelIDs{ {
   itk::simple::sitkLabelUInt8,
   itk::simple::sitkLabelUInt16,
   itk::simple::sitkLabelUInt32,
   itk::simple::sitkLabelUInt64} };

 return std::find(labelIDs.begin(), labelIDs.end(), img.GetPixelID()) != labelIDs.end();
}

TEST(BasicFilters, {{ name }}) {
 itk::simple::ImageFileReader reader;
 itk::simple::{{ name }} filter;
 itk::simple::Image inputA(0, 0, itk::simple::sitkUInt8);
 itk::simple::Image inputB(0, 0, itk::simple::sitkUInt8);
 itk::simple::Image output(0, 0, itk::simple::sitkUInt8);
 std::string inputSHA1hash;

 {% if tests|length == 0 %}
 //FAIL() << "Filter {{ name }} has no tests defined";
 {% endif %}

 {% for member in members %}
 {% if member.dim_vec and member.dim_vec == 1 %}
 for (unsigned int i = 0; i < filter.Get{{ member.name }}().size(); ++i) {
   EXPECT_EQ(filter.Get{{ member.name }}()[i], {{ member.default }}[i]) << "Testing get for {{ member.name }} at " << i;
 }
 {% elif not member.no_print %}
   EXPECT_EQ(filter.Get{{ member.name }}(), {{ member.default }}) << "Testing get for {{ member.name }}";
 {% endif %}
 {% endfor %}

 EXPECT_NE(filter.ToString(), "") << "empty ToString method!";
 EXPECT_EQ(filter.GetName(), "{{ name }}") << "checking GetName method!";

 // Test sets / gets
 {% for member in members %}
 {% if member.dim_vec and member.dim_vec == 1 %}
 filter.Set{{ member.name }}({{ member.default }});
 for (unsigned int i = 0; i < filter.Get{{ member.name }}().size(); ++i) {
   EXPECT_EQ(filter.Get{{ member.name }}()[i], {{ member.default }}[i]) << "Testing set/get for {{ member.name }} at " << i;
 }
 {% elif not member.no_print %}
 filter.Set{{ member.name }}({{ member.default }});
 EXPECT_EQ(filter.Get{{ member.name }}(), {{ member.default }}) << "Testing set/get for {{ member.name }}";
 {% endif %}
 {% endfor %}

 {% if number_of_inputs == 2 %}
 {
   itk::simple::Image smallImage(1, 1, 1, itk::simple::sitkUInt8);
   itk::simple::Image largeImage(10, 10, 10, itk::simple::sitkUInt8);
   itk::simple::Image smallShortImage(1, 1, 1, itk::simple::sitkUInt16);
   try {
     // Try executing with different size images.
     // This will either work or throw an exception, either is OK. So
     // this is here just to make sure that the behavior does not cause
     // undefined behavior such as segfault, or other erroneous behavior.
     filter.Execute(largeImage, smallImage);
   } catch (...) {}

   {% if template_code_filename == "DualImageFilter" %}
   // todo add intelligence to determine some image types to test
   // ASSERT_NO_THROW(filter.Execute(smallImage, smallShortImage)) << "Image types are different";
   {% else %}
     ASSERT_THROW(filter.Execute(smallImage, smallShortImage), itk::simple::GenericException) << "Image types are different";
   {% endif %}
 }
 {% endif %}

 // This block is to verify that the input images for named inputs are
 // checked if the sizes match for computation.
 {% if inputs %}
 itk::simple::Image smallImage(1, 1, 1, itk::simple::sitkUInt8);
 itk::simple::Image largeImage(10, 10, 10, itk::simple::sitkUInt8);
 {% for i in range(1, inputs|length) -%}
 {% if not inputs[i].optional and not inputs[i].no_size_check -%}

 EXPECT_THROW(filter.Execute(largeImage
                             {%- for j in range(1, inputs| length) -%}
                             {% if j == i %}, smallImage {% else %}, largeImage {% endif %}
                             {%- endfor -%}
                             ), itk::simple::GenericException);
 {% endif %}
 {%- endfor %}
 {%- endif %}
}

{% for test in tests %}
TEST(BasicFilters, {{ name }}_{{ test.tag }}) {
  itk::simple::ImageFileReader reader;
  itk::simple::{{ name }} filter;
  itk::simple::Image output;
  itk::simple::HashImageFilter hasher;
  std::string inputSHA1hash;

  std::vector<itk::simple::Image> inputs;
  std::vector<std::string> inputFileNames = { {{ test.inputs|map('quote')|join(", ") }} };

  for (unsigned int i = 0; i < inputFileNames.size(); ++i) {
    reader.SetFileName(dataFinder.GetFile(inputFileNames[i]));
    ASSERT_NO_THROW(inputs.push_back(reader.Execute())) << "Failed to load " << inputFileNames[i] << " from " << dataFinder.GetFile(inputFileNames[i]);

    {%- if test.inputA_cast -%}
    if (i == 0) {
      ASSERT_NO_THROW(inputs[i] = itk::simple::Cast(inputs[i], itk::simple::{{ test.inputA_cast }})) << "Failed to cast inputA to {{ test.inputA_cast }}";
    }
    {%- endif -%}
    {%- if test.inputB_cast -%}
    if (i == 1) {
      ASSERT_NO_THROW(inputs[i] = itk::simple::Cast(inputs[i], itk::simple::{{ test.inputB_cast }})) << "Failed to cast inputB to {{ test.inputB_cast }}";
    }
    {%- endif %}

    ASSERT_NE(inputs[i].GetITKBase(), nullptr) << "Could not read " << inputFileNames[i];
  }

  if (!inputs.empty()) {
    inputSHA1hash = itk::simple::Hash(inputs[0]);
  }


  {% if not (no_procedure or test.no_procedure) -%}
  itk::simple::Image fromFunctional(0, 0, itk::simple::sitkUInt8);
  itk::simple::Image fromProcedural(0, 0, itk::simple::sitkUInt8);
  EXPECT_NO_THROW(fromProcedural = filter.Execute({% for input in test.inputs %}inputs[{{ loop.index0 }}]{% if not loop.last %}, {% endif %}{% endfor %})) << "Procedural interface to {{ name }}";
  EXPECT_NO_THROW(fromFunctional = itk::simple::{{ name|replace("ImageFilter", "")|replace("Filter", "")|replace("ImageSource", "Source") }}({% for input in test.inputs %}inputs[{{ loop.index0 }}]{% if not loop.last %}, {% endif %}{% endfor %})) << "Functional interface to {{ name }}";
  hasher.SetHashFunction(itk::simple::HashImageFilter::MD5);
  EXPECT_EQ(hasher.Execute(fromProcedural), hasher.Execute(fromFunctional)) << "procedural and functional are not the same!";
  {%- endif %}

  {% if test.settings -%}
  {% for setting in test.settings -%}
  {% if setting.point_vec -%}
  filter.Clear{{ setting.parameter | replace('List', 's') }}();
  {% for value in setting.value -%}
  filter.Add{{ setting.parameter | replace('List', '') | regex_replace('s([0-9]?)$', '\\1') }}({{ value }});
  {%- endfor %}
  {%- elif setting.dim_vec -%}
  {
    std::vector<{{ setting.type }}> vec{
    {{ setting.value | join(", ") }}
    };
    filter.Set{{ setting.parameter }}(vec);
    for (unsigned int i = 0; i < filter.Get{{ setting.parameter }}().size(); ++i) {
      ASSERT_EQ(filter.Get{{ setting.parameter }}()[i], vec[i]) << "Failed to set {{ setting.parameter }} to: \"" << vec << "\"";
    }
  }
  {%- else -%}
  {%- set value = setting.cxx_value if setting.cxx_value else setting.value %}
  filter.Set{{ setting.parameter }}({{ value  }});
  {% if not setting.no_get_method -%}
  ASSERT_EQ({{ value  }}, filter.Get{{ setting.parameter }}()) << "Failed to set {{ setting.parameter }} to: \"" << {{ value }} << "\"";
  {%- endif %}
  {%- endif %}
  {%- endfor %}
  {%- endif %}

  filter.DebugOn();
  ASSERT_NO_THROW({% if not no_return_image %}output = {% endif %}filter.Execute({% for input in test.inputs %}inputs[{{ loop.index0 }}]{% if not loop.last %}, {% endif %}{% endfor %}));

  if (!inputs.empty()) {
    EXPECT_EQ(inputSHA1hash, itk::simple::Hash(inputs[0])) << "Input was modified by filter.";

    if (!isLabelType(output) && !isLabelType(inputs[0])) {
      EXPECT_NE(output.GetBufferAsVoid(), inputs[0].GetBufferAsVoid()) << "Input buffer was copied to output!";
    }
  }

  {% if in_place -%}
  ASSERT_LE(1u, inputs.size());
  itk::simple::Image inPlaceOutput;
  itk::simple::Image temp = inputs[0];
  temp.MakeUnique();
  ASSERT_NO_THROW({% if not no_return_image %}inPlaceOutput = {% endif %}filter.Execute({% if test.inputs|length > 0 %}std::move(temp){% endif %}{% for i in range(1, test.inputs|length) %}, inputs[{{ i }}]{% endfor %}));

  ASSERT_NE(nullptr, inPlaceOutput.GetITKBase());
  EXPECT_EQ(itk::simple::Hash(output), itk::simple::Hash(inPlaceOutput)) << "InPlace value does not match!";

  for (auto iter = ++(inputs.begin()); iter != inputs.end(); ++iter) {
    ASSERT_NE(nullptr, iter->GetITKBase());
    if (!isLabelType(*iter)) {
      EXPECT_NE(nullptr, iter->GetBufferAsVoid()) << "An input is missing its buffer!";

      if (!isLabelType(inPlaceOutput)) {
        EXPECT_NE(inPlaceOutput.GetBufferAsVoid(), iter->GetBufferAsVoid()) << "An input and output buffer matches.";
      }
    }
  }
  {% endif -%}

  {% if test.md5hash -%}
  IMAGECOMPAREWITHHASH("{{ test.md5hash }}", MD5, output, "Output MD5 hash failed in {{ test.tag }}");
  {%-endif %}
  {% if test.tolerance -%}
  IMAGECOMPAREWITHTOLERANCE(output, "", {{ test.tolerance }});
  {%- endif %}

  {% for result in test.measurements_results -%}
  {% set measurement = measurements | selectattr('name', 'equalto', result.name) | first %}
  {% if result.tolerance %}
  {% if result.dim_vec -%}
  {
        const std::vector<double> vec1({ {{ result.value | join(", ")}} });
        EXPECT_VECTOR_NEAR(vec1, filter.Get{{ result.name }}({{ result.parameters | join(", ") }}), {{ result.tolerance }}) << "Measurement failure";
  }
  {%- else %}
  EXPECT_NEAR({% if measurement and measurement.type %}static_cast<{{ measurement.type }}>({{ result.value }}){% else %}{{ result.value }}{% endif %}, filter.Get{{ result.name }}({{ result.parameters | join(", ") }}), {{ result.tolerance }}) << "Measurement failure";
  {% endif %}
  {% else %}
  {% if result.value == "true" %}
  EXPECT_TRUE(filter.Get{{ result.name }}({{ result.parameters | join(", ") }})) << "Measurement failure";
  {% elif result.value == "false" %}
  EXPECT_FALSE(filter.Get{{ result.name }}({{ result.parameters | join(", ") }})) << "Measurement failure";
  {% else %}
  EXPECT_EQ({% if measurement and measurement.type %}static_cast<{{ measurement.type }}>({{ result.value }}){% else %}{{ result.value }}{% endif %}, filter.Get{{ result.name }}({{ result.parameters | join(", ") }})) << "Measurement failure";
  {% endif %}
  {% endif %}
  {%- endfor %}
}
{% endfor %}
