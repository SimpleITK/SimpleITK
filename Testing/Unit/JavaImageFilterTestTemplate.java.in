/*=========================================================================
 *
 *  Copyright Insight Software Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at JavaImageFilterTestTemplate.java.in to make changes.
 */

import java.math.BigInteger;
// This is Java code to test ${name}
import org.itk.simple.*;
import java.util.Arrays;


class BigIntergerFix {
  public static long Convert( long referenceType, long value) {
    return value;
  }

  public static BigInteger Convert(BigInteger referenceType, long value)
  {
    return BigInteger.valueOf(value);
  }
}

class ${name}Test {

  public static void main( String argv[] ) {

    // Get the right number of inputs
    int num_inputs = 1;
    $(if number_of_inputs then
        OUT=[[num_inputs = ${number_of_inputs};]]
      end)

    // Check the command line arguments
    if ( argv.length < num_inputs + 1 ) {
      System.out.println("Usage: ${name} tag <input(s)> output");
      return;
    }

    String tag = argv[0];

    // Instantiate objects
    ImageFileReader reader = new ImageFileReader();
    ImageFileWriter writer = new ImageFileWriter();
    ${name} filter = new ${name}();

    $(if #tests == 0 then
    OUT=[[
    // No tests defined => exit with error code
    System.out.println ( "No tests defined!" );
    System.exit ( 1 );
    ]]
    end)

    // Run each testzf
$(foreach tests
    if (tag.equals( "${tag}" )) {


      Image[] inputs;
      inputs = new Image[ ${#inputs} ];

     // Read image(s)
$(for i=0,#inputs-1 do
OUT=OUT..[[
      reader.setFileName( argv[]]..i..[[+1] );
      inputs[]]..i..[[] = reader.execute();
]]
end)

      CastImageFilter caster = new CastImageFilter();
$(if inputA_cast then
 OUT=[[
      caster.setOutputPixelType( PixelIDValueEnum.${inputA_cast} );
      inputs[0]  = caster.execute( inputs[0] );
]]
end)$(if inputB_cast then
 OUT=[[
      caster.setOutputPixelType( PixelIDValueEnum.${inputB_cast} );
      inputs[1]  = caster.execute( inputs[1] );
]]
end)

      $(when settings
      // Set parameters
      $(foreach settings
$(if parameter == "SeedList" then
      OUT=[[filter.clearSeeds();
      $(for i=1,#value do OUT=OUT .. "{\
        int v[] = " .. value[i] .. ";\
        VectorUInt32 idx = new VectorUInt32();\
        for (int i = 0; i < inputs[0].getDimension(); i++) {\
          idx.add(v[i]);\
        }\
        filter.addSeed(idx);\
      }\
      " end)]]
elseif parameter == "TrialPoints" then
      OUT=[[filter.clearTrialPoints();
      $(for i=1,#value do OUT=OUT .. "{\
        int v[] = " .. value[i] .. ";\
        VectorUInt32 idx = new VectorUInt32();\
        for (int i = 0; i < inputs[0].getDimension(); i++) {\
          idx.add(v[i]);\
        }\
        filter.addTrialPoint(idx);\
      }\
      " end)]]
elseif point_vec and point_vec == 1 then
    OUT=[[
                filter.clear${parameter}();
]]
    for i=1,#value do
      OUT=OUT.. [[
                {
                  int v[] = ]] .. value[i] .. [[;
                  VectorUInt32 pts = new VectorUInt32( );
                  for (int i = 0; i < inputs[0].getDimension(); i++) {
                    pts.add(v[i]);
                  }
                  filter.add${parameter:gsub('s([0-9]?)$','%1')}(pts);
                }
]]
     end
elseif dim_vec == 1 then
      OUT=[[
      {
        $(if type == "bool" then
          OUT="Boolean"
        elseif type == "unsigned int" then
          OUT="int"
        elseif type == "unsigned long" then
          OUT="long"
        elseif type == "unsigned short" then
          OUT="short"
        elseif type == "uint8_t" then
          OUT="short"
        elseif type == "uint16_t" then
          OUT="short"
        elseif type == "uint32_t" then
          OUT="int"
        elseif type == "uint64_t" then
          OUT="long"
        else
          OUT="${type}"
        end) v[] = $(if java_value then
          OUT=OUT..java_value
          else
            OUT=OUT..'{'
            for i=1,#value-1 do
              OUT=OUT..value[i]..", "
            end
          OUT=OUT..value[#value]..'}'
          end);
        $(if type == "bool" then
          OUT="VectorBool idx = new VectorBool( v.length );"
        elseif type == "unsigned int" then
          OUT="VectorUInt32 idx = new VectorUInt32( v.length );"
        elseif type == "int" then
          OUT="VectorInt32 idx = new VectorInt32( v.length );"
        elseif type == "unsigned long" then
         OUT="VectorULong idx = new VectorULong( v.length );"
        elseif type == "long" then
         OUT="VectorLong idx = new VectorLong( v.length );"
        elseif type == "unsigned short" then
          OUT="VectorUShort idx = new VectorUShort( v.length );"
        elseif type == "short" then
          OUT="VectorShort idx = new VectorShort( v.length );"
        elseif type == "float" then
          OUT="VectorFloat idx = new VectorFloat( v.length );"
        elseif type == "double" then
          OUT="VectorDouble idx = new VectorDouble( v.length );"
        elseif type == "uint8_t" then
          OUT="VectorUInt8 idx = new VectorUInt8( v.length );"
        elseif type == "uint16_t" then
          OUT="VectorUInt16 idx = new VectorUInt16( v.length );"
        elseif type == "uint32_t" then
          OUT="VectorUInt32 idx = new VectorUInt32( v.length );"
        elseif type == "uint64_t" then
          OUT="VectorUInt64 idx = new VectorUInt64( v.length );"
        elseif type == "int8_t" then
          OUT="VectorInt8 idx = new VectorInt8( v.length );"
        elseif type == "int16_t" then
          OUT="VectorInt16 idx = new VectorInt16( v.length );"
        elseif type == "int32_t" then
          OUT="VectorInt32 idx = new VectorInt32( v.length );"
        elseif type == "int64_t" then
          OUT="VectorInt64 idx = new VectorInt64( v.length );"
        end)

        for (int i = 0; i < v.length; i++) {
          idx.set( i, v[i] );
        }
        filter.set${parameter}(idx);
      }]]
elseif type == "uint64_t" then
OUT=[[
  filter.set${parameter}( BigIntergerFix.Convert( filter.get${parameter}(), $(if java_value then OUT='${java_value}' else OUT='${value}' end) ) );
]]
else
OUT=[[
      filter.set${parameter}( $(if java_value then OUT='${java_value}' else OUT='${value}' end) );
]]
end)
)
)

      // Run the filter
      $(if not no_return_image then OUT=[[Image output =]] end) filter.execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) );

      PixelIDValueEnum[] labelIDs = { PixelIDValueEnum.sitkLabelUInt8, PixelIDValueEnum.sitkLabelUInt16, PixelIDValueEnum.sitkLabelUInt32, PixelIDValueEnum.sitkLabelUInt64 };

$(if not no_return_image then
OUT=[[
      if (Arrays.asList(labelIDs).contains(output.getPixelID()))
        {
          LabelMapToLabelImageFilter toImage = new LabelMapToLabelImageFilter();
          output = toImage.execute(output);
        }

      // Write output
      writer.setFileName( argv[argv.length - 1] );
      writer.execute( output );
]]
end)
    }
)
  }
}
