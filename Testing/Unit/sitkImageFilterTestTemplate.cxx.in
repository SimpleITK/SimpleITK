#include <SimpleITKTestHarness.h>

#include <sitk${name}ImageFilter.h>
#include <sitkImageFileReader.h>
#include <sitkImageFileWriter.h>
#include <sitkHashImageFilter.h>

#define VERIFYHASH(hash,hashType,image,message)    \
  {                                             \
  std::string actualHashValue = hasher.SetHashFunction ( itk::simple::HashImageFilter::hashType ).Execute ( image.get() ); \
  EXPECT_EQ ( hash, actualHashValue  ) << message;                      \
  if ( hash != actualHashValue ) {                                      \
    itk::simple::WriteImage ( image.get(), dataFinder.GetOutputFile ( actualHashValue + ".nrrd" ) ); \
    std::cout << "Saved image as " << dataFinder.GetOutputFile ( actualHashValue + ".nrrd" ) << std::endl; \
  }                                                                     \
  }


TEST(BasicFilters,${name}) {
  itk::simple::ImageFileReader reader;
  itk::simple::${name}ImageFilter filter;
  std::auto_ptr<itk::simple::Image> inputA;
  std::auto_ptr<itk::simple::Image> inputB;
  std::auto_ptr<itk::simple::Image> output;
  itk::simple::HashImageFilter hasher;
  std::string inputSHA1hash;

  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing get for ${name}";]]
end)
)
  EXPECT_NE ( filter.ToString(), "" ) << "empty ToString method!";

  // Test sets / gets
$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[filter.Set${name} ( ${default} );
  for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing set/get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[filter.Set${name} ( ${default} );
  EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing set/get for ${name}";]]
end)
)

$(if template_type and template_type == "RegionGrowing" then OUT=[[
  // Test size of default SeedList
  EXPECT_EQ ( filter.GetSeedList().size(), (unsigned int)0 ) << "Testing empty seed list as default";]]
end)

 $(if number_of_inputs == 2 then
   OUT=[[ {
  std::auto_ptr<itk::simple::Image> smallImage      ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) );
  std::auto_ptr<itk::simple::Image> largeImage      ( new itk::simple::Image ( 10,10,10,itk::simple::sitkUInt8 ) );
  std::auto_ptr<itk::simple::Image> smallShortImage ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt16 ) );
  ASSERT_THROW ( filter.Execute ( smallImage.get(), largeImage.get() ), itk::simple::GenericException ) << " Image sizes are different";
  ASSERT_THROW ( filter.Execute ( smallImage.get(), smallShortImage.get() ), itk::simple::GenericException ) << " Image types are different";
  }]]
   end)


  bool firstPassSoTestFunctional = true;
  $(foreach tests
    /* ${description} */
  ASSERT_NO_THROW ( inputA.reset ( reader.SetFileName ( dataFinder.GetFile ( "${inputA}" ) ).Execute() ) ) << "Failed to load ${inputA}";
  ASSERT_TRUE ( inputA->GetImageBase().IsNotNull() ) << "Could not read ${inputA}";
    $(if inputB then
      OUT=[[
  ASSERT_NO_THROW ( inputB.reset ( reader.SetFileName ( dataFinder.GetFile ( "${inputB}" ) ).Execute() ) ) << "Failed to load ${inputB}";
  ASSERT_TRUE ( inputB->GetImageBase().IsNotNull() ) << "Could not read ${inputB}";
            ]]
      end)

    if ( firstPassSoTestFunctional ) {
      firstPassSoTestFunctional = false;

      // Do we get the same image back, if we use the functional interface?
      std::auto_ptr<itk::simple::Image> fromFunctional, fromProcedural;
      ASSERT_NO_THROW ( fromProcedural.reset ( filter.Execute ( inputA.get() $(if inputB then OUT=", inputB.get()" end) ) ) ) << "Procedural interface to ${name}";
      ASSERT_NO_THROW ( fromFunctional.reset ( itk::simple::${name} ( inputA.get() $(if inputB then OUT=", inputB.get()" end)
                                                                         $(if template_type and template_type == "RegionGrowing" then OUT=", std::vector< std::vector<unsigned int> >()" end)
                                                                      $(if template_code_filename and template_code_filename == "KernelImageFilter" then OUT=[[, 1, itk::simple::${name}ImageFilter::Ball]] end)
                                                                         $(foreach members , ${default})
                                                                      ) ) ) << "Functional interface to ${name}";
      hasher.SetHashFunction ( itk::simple::HashImageFilter::MD5 );
      EXPECT_EQ ( hasher.Execute ( fromProcedural.get() ), hasher.Execute ( fromFunctional.get() ) ) << "procedural and functional are not the same!";
    }


$(if settings then
OUT=[[
$(foreach settings
  $(if parameter == "SeedList" then
  OUT='filter.ClearSeeds();\
  $(for i=1,#value do OUT=OUT .. "{unsigned int __seed[] = " .. value[i] .. "; filter.AddSeed( std::vector<unsigned int>(__seed, __seed + inputA->GetDimension()) );}" end);'
  elseif dim_vec and dim_vec == 1 then
  OUT='{\
  ${type} arr[] = ${value};\
  std::vector< ${type} > vec(arr, arr + sizeof(arr)/sizeof(${type}));\
  filter.Set${parameter} ( vec );\
  for(unsigned int i = 0; i < filter.Get${parameter}().size(); ++i)\
    {\
    ASSERT_EQ ( filter.Get${parameter}()[i], vec[i] ) << "Failed to set ${parameter} to ${value}";\
    }\
  }'
  else
    OUT='filter.Set${parameter} ( ${value} );'
      if (not no_get_method) then
    OUT = OUT .. '\
  ASSERT_EQ ( ${value}, filter.Get${parameter}() ) << "Failed to set ${parameter} to ${value}";'
    end
end)
)]]
end)

  inputSHA1hash =  itk::simple::Hash( inputA.get() );
  ASSERT_NO_THROW ( output.reset ( filter.Execute ( inputA.get() $(if inputB then OUT=", inputB.get()" end) ) ) );

  // Check that the input is not modified
  // This will fail if the filter is being run in-place
  EXPECT_EQ ( inputSHA1hash,  itk::simple::Hash( inputA.get() ) ) << "Input was modified by filter.";

  $(if md5hash then
  OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
  ]]
  end)
  $(if sha1hash then
  OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
  ]]
  end)
  $(if tolerance then
  OUT = [[
 IMAGECOMPAREWITHTOLERANCE ( output.get(), "${tag}", ${tolerance} );
  ]]
  end)
  )
}

#if defined(WRAP_LUA)

TEST_F(Lua,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/LuaTests/${name}ImageFilterTest.lua";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Lua-${name}-${tag}.nrrd" );
    // Make sure the output is wiped
    EXPECT_NO_THROW ( itk::simple::ImageFileWriter()
                      .SetFileName ( outputFileName )
                      .Execute ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) ) ) << "Failed to overwrite";
    CommandLine.push_back ( dataFinder.GetLuaExecutable() );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
    CommandLine.push_back ( dataFinder.GetFile ( "${inputA}" ) );
    $(if inputB then
      OUT=[[  CommandLine.push_back ( dataFinder.GetFile ( "${inputB}" ) );]]
      end)
    CommandLine.push_back ( outputFileName );
    RunExecutable ( CommandLine, true );
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    std::auto_ptr<itk::simple::Image> output;

    output.reset(reader.SetFileName ( outputFileName ).Execute());
    ASSERT_TRUE ( output.get() != NULL );
    ASSERT_TRUE ( output->GetImageBase().IsNotNull() ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output.get(), "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_PYTHON)

TEST_F(Python,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  // Set our python path
  std::string path = dataFinder.GetBuildDirectory() + "/Wrapping"
    + GetPathSeparator() + dataFinder.GetExecutableDirectory();
  SetEnvironment ( "PYTHONPATH", path );

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/PythonTests/${name}ImageFilterTest.py";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Python-${name}-${tag}.nrrd" );
    // Make sure the output is wiped
    EXPECT_NO_THROW ( itk::simple::ImageFileWriter()
                      .SetFileName ( outputFileName )
                      .Execute ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) ) ) << "Failed to overwrite";
    CommandLine.push_back ( dataFinder.GetPythonExecutable() );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
    CommandLine.push_back ( dataFinder.GetFile ( "${inputA}" ) );
    $(if inputB then
      OUT=[[  CommandLine.push_back ( dataFinder.GetFile ( "${inputB}" ) );]]
      end)
    CommandLine.push_back ( outputFileName );
    RunExecutable ( CommandLine, true );
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    std::auto_ptr<itk::simple::Image> output;

    output.reset ( reader.SetFileName ( outputFileName ).Execute() );
    ASSERT_TRUE ( output.get() != NULL );
    ASSERT_TRUE ( output->GetImageBase().IsNotNull() ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output.get(), "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_TCL)

TEST_F(Tcl,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/TclTests/${name}ImageFilterTest.tcl";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Tcl-${name}-${tag}.nrrd" );
    // Make sure the output is wiped
    EXPECT_NO_THROW ( itk::simple::ImageFileWriter()
                      .SetFileName ( outputFileName )
                      .Execute ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) ) ) << "Failed to overwrite";
    CommandLine.push_back ( dataFinder.FindExecutable ( "SimpleITKTclsh" ) );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
    CommandLine.push_back ( dataFinder.GetFile ( "${inputA}" ) );
    $(if inputB then
      OUT=[[  CommandLine.push_back ( dataFinder.GetFile ( "${inputB}" ) );]]
      end)
    CommandLine.push_back ( outputFileName );
    RunExecutable ( CommandLine, true );
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    std::auto_ptr<itk::simple::Image> output;

    output.reset ( reader.SetFileName ( outputFileName ).Execute() );
    ASSERT_TRUE ( output.get() != NULL );
    ASSERT_TRUE ( output->GetImageBase().IsNotNull() ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output.get(), "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_R)

TEST_F(R,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/RTests/${name}ImageFilterTest.R";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "R-${name}-${tag}.nrrd" );
    // Make sure the output is wiped
    EXPECT_NO_THROW ( itk::simple::ImageFileWriter()
                      .SetFileName ( outputFileName )
                      .Execute ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) ) ) << "Failed to overwrite";
    CommandLine.push_back ( dataFinder.GetRExecutable() );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
    CommandLine.push_back ( dataFinder.GetFile ( "${inputA}" ) );
    $(if inputB then
      OUT=[[  CommandLine.push_back ( dataFinder.GetFile ( "${inputB}" ) );]]
      end)
    CommandLine.push_back ( outputFileName );
    RunExecutable ( CommandLine, true );
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    std::auto_ptr<itk::simple::Image> output;

    output.reset ( reader.SetFileName ( outputFileName ).Execute() );
    ASSERT_TRUE ( output.get() != NULL );
    ASSERT_TRUE ( output->GetImageBase().IsNotNull() ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output.get(), "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif



#if defined(WRAP_JAVA)

TEST_F(Java,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Classpath = dataFinder.GetBuildDirectory() + "/Testing/Unit/JavaTests"
    + dataFinder.GetPathSeparator() + dataFinder.GetBuildDirectory() + "/Wrapping/org.itk.simple.jar";
  std::string JavaPath = dataFinder.GetExecutableDirectory();
  std::string Script = "org.itk.simple.testing.${name}ImageFilterTest";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Java-${name}-${tag}.nrrd" );
    // Make sure the output is wiped
    EXPECT_NO_THROW ( itk::simple::ImageFileWriter()
                      .SetFileName ( outputFileName )
                      .Execute ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) ) ) << "Failed to overwrite";
    CommandLine.push_back ( dataFinder.GetJavaExecutable() );
    CommandLine.push_back ( "-classpath" );
    CommandLine.push_back ( Classpath );
    CommandLine.push_back ( "-Djava.library.path=" + JavaPath );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
    CommandLine.push_back ( dataFinder.GetFile ( "${inputA}" ) );
    $(if inputB then
      OUT=[[  CommandLine.push_back ( dataFinder.GetFile ( "${inputB}" ) );]]
      end)
    CommandLine.push_back ( outputFileName );
    RunExecutable ( CommandLine, true );
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    std::auto_ptr<itk::simple::Image> output;

    output.reset ( reader.SetFileName ( outputFileName ).Execute() );
    ASSERT_TRUE ( output.get() != NULL );
    ASSERT_TRUE ( output->GetImageBase().IsNotNull() ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output.get(), "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_RUBY)

TEST_F(Ruby,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  // Set our Ruby path
  SetEnvironment ( "RUBYLIB", dataFinder.GetExecutableDirectory() );

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/RubyTests/${name}ImageFilterTest.rb";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Ruby-${name}-${tag}.nrrd" );
    // Make sure the output is wiped
    EXPECT_NO_THROW ( itk::simple::ImageFileWriter()
                      .SetFileName ( outputFileName )
                      .Execute ( new itk::simple::Image ( 1,1,1,itk::simple::sitkUInt8 ) ) ) << "Failed to overwrite";
    CommandLine.push_back ( dataFinder.GetRubyExecutable() );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
    CommandLine.push_back ( dataFinder.GetFile ( "${inputA}" ) );
    $(if inputB then
      OUT=[[  CommandLine.push_back ( dataFinder.GetFile ( "${inputB}" ) );]]
      end)
    CommandLine.push_back ( outputFileName );
    RunExecutable ( CommandLine, true );
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    std::auto_ptr<itk::simple::Image> output;

    output.reset ( reader.SetFileName ( outputFileName ).Execute() );
    ASSERT_TRUE ( output.get() != NULL );
    ASSERT_TRUE ( output->GetImageBase().IsNotNull() ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  VERIFYHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output.get(), "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif
