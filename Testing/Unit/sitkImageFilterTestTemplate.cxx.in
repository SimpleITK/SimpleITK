/*=========================================================================
*
*  Copyright NumFOCUS
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at sitkImageFilterTestTemplate.cxx.in to make changes.
 */

#include <SimpleITKTestHarness.h>

#include <sitk${name}.h>
#include <sitkImageFileReader.h>
#include <sitkImageFileWriter.h>
#include <sitkHashImageFilter.h>
#include <sitkCastImageFilter.h>
#include <sitkConditional.h>
#include <sitkVersion.h>

#include <array>

static bool isLabelType( const itk::simple::Image &img)
{
  static const std::array<itk::simple::PixelIDValueEnum, 4> labelIDs{{
      itk::simple::sitkLabelUInt8,
      itk::simple::sitkLabelUInt16,
      itk::simple::sitkLabelUInt32,
      itk::simple::sitkLabelUInt64}};

  return std::find(labelIDs.begin(), labelIDs.end(), img.GetPixelID()) != labelIDs.end();
}

TEST(BasicFilters,${name}) {
  itk::simple::ImageFileReader reader;
  itk::simple::${name} filter;
  itk::simple::Image inputA( 0, 0, itk::simple::sitkUInt8 );
  itk::simple::Image inputB( 0, 0, itk::simple::sitkUInt8 );
  itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
  std::string inputSHA1hash;

  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing get for ${name}";]]
end)
)
  EXPECT_NE ( filter.ToString(), "" ) << "empty ToString method!";
  EXPECT_EQ ( filter.GetName(), "${name}" ) << "checking GetName method!";

  // Test sets / gets
$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[filter.Set${name} ( ${default} );
  for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing set/get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[filter.Set${name} ( ${default} );
  EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing set/get for ${name}";]]
end)
)

$(if number_of_inputs == 2 then
   OUT=[[ {
  itk::simple::Image smallImage( 1,1,1,itk::simple::sitkUInt8 );
  itk::simple::Image largeImage( 10,10,10,itk::simple::sitkUInt8 );
  itk::simple::Image smallShortImage( 1,1,1,itk::simple::sitkUInt16 );
  try
    {
    // Try executing with different size images.
    // This will either work or throw an exception, either is OK. So
    // this is here just to make sure that the behavior does not cause
    // undefined behavior such as segfault, or other errouneos behavior.
    filter.Execute ( largeImage, smallImage );
    } catch (... )
    { }
]]
  if template_code_filename and template_code_filename == "DualImageFilter" then
    OUT = OUT .. [=[
        // todo add intelligence to determin some image types to test
        //ASSERT_NO_THROW ( filter.Execute ( smallImage, smallShortImage ) ) << " Image types are different";
]=]
  else
    OUT = OUT .. [=[

  ASSERT_THROW ( filter.Execute ( smallImage, smallShortImage ), itk::simple::GenericException ) << " Image types are different"; ]=]
  end
  OUT = OUT .. [[
  }]]
   end)
  // This block is to verify that the input images for named inputs are
  // check if the sizes match for computation.
$(if inputs then
OUT = OUT .. [[
  itk::simple::Image smallImage( 1,1,1,itk::simple::sitkUInt8 );
  itk::simple::Image largeImage( 10,10,10,itk::simple::sitkUInt8 );
]]
    for inum=2,#inputs do
      if  not inputs[inum].optional and not inputs[inum].no_size_check then
        OUT = OUT .. [[
  EXPECT_THROW ( filter.Execute ( largeImage]]
        for jnum=2,#inputs do
         if jnum == inum then
           OUT = OUT .. [[, smallImage]]
         elseif not inputs[jnum].optional then
           OUT = OUT .. [[, largeImage]]
         end
        end
        OUT = OUT .. [[ ), itk::simple::GenericException);
]]
      end
     end

  end)
}

$(foreach tests
TEST(BasicFilters,${name}_${tag})
  { // BEGIN FOR EACH TEST
  /* TAG: ${tag} DESCRIPTION: ${description} */

  itk::simple::ImageFileReader reader;
  itk::simple::${name} filter;
  itk::simple::Image output;
  itk::simple::HashImageFilter hasher;
  std::string inputSHA1hash;

  std::vector<itk::simple::Image> inputs;
  std::vector<std::string> inputFileNames;

$(for inum=1,#inputs do
    OUT=OUT..[[
  inputFileNames.push_back( "]]..inputs[inum]..[["  );
]]
end)

  for ( unsigned int i = 0; i < inputFileNames.size(); ++i )
    {
    ASSERT_NO_THROW ( inputs.push_back( reader.SetFileName ( dataFinder.GetFile ( inputFileNames[i]  ) ).Execute() ) ) << "Failed to load " << inputFileNames[i] << " from " << dataFinder.GetFile ( inputFileNames[i]  );

$(if inputA_cast then
      OUT=[[
      if ( i == 0 )
        {
          ASSERT_NO_THROW( inputs[i]  = itk::simple::Cast( inputs[i], itk::simple::${inputA_cast } ) ) << "Failed to cast inputA to ${inputA_cast}";
        }
]] end)$(if inputB_cast then
      OUT=[[
    if ( i == 1 )
      {
      ASSERT_NO_THROW( inputs[i] = itk::simple::Cast( inputs[i], itk::simple::${inputB_cast } ) ) << "Failed to cast inputB to ${inputB_cast}";
      }
]] end)
    ASSERT_NE ( inputs[i].GetITKBase(), nullptr ) << "Could not read " << inputFileNames[i];
    }

    if ( !inputs.empty() )
      {
      inputSHA1hash =  itk::simple::Hash( inputs[0] );
      }

  $(if (not no_procedure) or (no_procedure ==0) then
OUT=[=[

      // Do we get the same image back, if we use the functional interface?
      itk::simple::Image fromFunctional( 0, 0, itk::simple::sitkUInt8 );
      itk::simple::Image fromProcedural( 0, 0, itk::simple::sitkUInt8 );
      EXPECT_NO_THROW ( fromProcedural = filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) ) << "Procedural interface to ${name}";
      EXPECT_NO_THROW ( fromFunctional = itk::simple::${name:gsub("ImageFilter$", ""):gsub("Filter$", ""):gsub("ImageSource$", "Source")} ( $(if true then
local count = 0
if #inputs > 0 then
  OUT=[[inputs[0] ]]
  count = count + 1
end
for inum=1,#inputs-1 do
  OUT=OUT..", inputs["..inum.."]"
  count = count + 1
end
if template_code_filename and template_code_filename == "KernelImageFilter" then
  OUT=OUT..[[, 1, itk::simple::sitkBall]]
  count = count + 1
end
for i = 1,#members do
  if count > 0 then
    OUT = OUT .. ", "
  end
  count = count + 1
  OUT= OUT .. members[i].default
end
end)) ) << "Functional interface to ${name}";
      hasher.SetHashFunction ( itk::simple::HashImageFilter::MD5 );
      EXPECT_EQ ( hasher.Execute ( fromProcedural ), hasher.Execute ( fromFunctional ) ) << "procedural and functional are not the same!";
]=] end)


$(if settings then
OUT=[[
$(foreach settings
  $(if point_vec and point_vec == 1 then
    OUT="filter.Clear${parameter:gsub('List','s')}();\n"
    for i=1,#value do
      OUT=OUT.."  filter.Add${parameter:gsub('List',''):gsub('s(%d?)$','%1')}("..value[i].." );\n"
     end
  elseif dim_vec and dim_vec == 1 then
  OUT='{\
  ${type} arr[] = {'
  for i=1,#value-1 do
    OUT=OUT..value[i]..", "
  end
  OUT=OUT..value[#value]
  OUT=OUT..'};\
  std::vector< ${type} > vec(arr, arr + sizeof(arr)/sizeof(${type}));\
  filter.Set${parameter} ( vec );\
  for(unsigned int i = 0; i < filter.Get${parameter}().size(); ++i)\
    {\
    ASSERT_EQ ( filter.Get${parameter}()[i], vec[i] ) << "Failed to set ${parameter} to: \\\"" << vec << "\\\"";\
    }\
  }'
  else
    if cxx_value then
      temp = cxx_value
    else
      temp = value
    end
    OUT='filter.Set${parameter} ( ${temp} );'
      if (not no_get_method) then
        if (temp == "true") then
          OUT = OUT .. '\
  ASSERT_TRUE ( filter.Get${parameter}() ) << "Failed to set ${parameter} to ${temp}";'
        elseif (temp == "false") then
          OUT = OUT .. '\
  ASSERT_FALSE ( filter.Get${parameter}() ) << "Failed to set ${parameter} to ${temp}";'
        else
          OUT = OUT .. '\
  ASSERT_EQ ( ${temp}, filter.Get${parameter}() ) << "Failed to set ${parameter} to: \\\"" << ${temp} << "\\\"";'
        end
      end
end)
)]]
end)


   filter.DebugOn();
  ASSERT_NO_THROW ( $(if not no_return_image then OUT=[[output =]] end) filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) );

  if ( !inputs.empty() )
    {

      // Check that the input is not modified
      // This will fail if the filter is being run in-place
      EXPECT_EQ ( inputSHA1hash,  itk::simple::Hash( inputs[0] ) ) << "Input was modified by filter.";

      // Check that the input buffer is different that the output
      // buffer, this does not check complex or label map pixel types.
      if(!isLabelType(output) && !isLabelType(inputs[0]))
        {
        EXPECT_NE(output.GetBufferAsVoid(), inputs[0].GetBufferAsVoid() ) << "Input buffer was copyied to output!";
        }
    }

$(if in_place then
    OUT=OUT..[=[
  ASSERT_LE(1u, inputs.size());
  itk::simple::Image inPlaceOutput;
  itk::simple::Image temp = inputs[0];
  temp.MakeUnique();
  ASSERT_NO_THROW ( $(if not no_return_image then OUT=[[inPlaceOutput =]] end) filter.Execute ( $(if #inputs > 0 then OUT=[[std::move(temp)]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) );

  ASSERT_NE(nullptr, inPlaceOutput.GetITKBase());
  EXPECT_EQ(itk::simple::Hash(output), itk::simple::Hash(inPlaceOutput)) << "InPlace value does not match!";

  for( auto iter = ++(inputs.begin()); iter != inputs.end(); ++iter)
    {
    ASSERT_NE(nullptr, iter->GetITKBase());
    if (!isLabelType(*iter))
      {
      EXPECT_NE(nullptr, iter->GetBufferAsVoid()) << "An input is missing it's buffer!";

      if (!isLabelType(inPlaceOutput))
        {
        EXPECT_NE(inPlaceOutput.GetBufferAsVoid(), iter->GetBufferAsVoid()) << "An input and output buffer matches.";
        }
      }
    }
]=]
end)


  $(if md5hash then
  OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed in ${tag}");]]
  end)
  $(if sha1hash then
  OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed in ${tag}"); ]]
  end) $(if tolerance then
  OUT = [[
 IMAGECOMPAREWITHTOLERANCE ( output, "", ${tolerance} );
  ]]end)
$(when measurements_results
$(for i = 1,#measurements_results do
  PARAMS=''
  if measurements_results[i].parameters then
    for pnum=1,#measurements_results[i].parameters do
    if not pnum == 1 then
        PARAMS=PARAM..','
      end
       PARAMS=PARAMS..' '..measurements_results[i].parameters[pnum]
    end
    PARAMS=PARAMS..' '
  end
  if measurements_results[i].tolerance then
    if measurements_results[i].dim_vec then
      OUT=OUT..'{\
   double arr[] = {'
      for j=1,#measurements_results[i].value-1 do
        OUT=OUT..measurements_results[i].value[j]..", "
      end
      OUT=OUT..measurements_results[i].value[#measurements_results[i].value]
      OUT=OUT..'};\
   std::vector< double > vec1(arr, arr + '..#measurements_results[i].value..');\
   EXPECT_VECTOR_NEAR( vec1, filter.Get'..measurements_results[i].name..'('..PARAMS..'), '..measurements_results[i].tolerance..' ) << "Measurement failure";\
   }'
    else
      OUT=OUT..'  EXPECT_NEAR( '..measurements_results[i].value..', filter.Get'..measurements_results[i].name..'('..PARAMS..'), '..measurements_results[i].tolerance..' ) << "Measurement failure";'
    end
  else
    if (measurements_results[i].value == "true") then
      OUT=OUT..'  EXPECT_TRUE( filter.Get'..measurements_results[i].name..'('..PARAMS..') ) << "Measurement failure";'
    elseif (measurements_results[i].value == "false") then
      OUT=OUT..'  EXPECT_FALSE( filter.Get'..measurements_results[i].name..'('..PARAMS..') ) << "Measurement failure"; '
    else
      OUT=OUT..'  EXPECT_EQ( '..measurements_results[i].value..', filter.Get'..measurements_results[i].name..'('..PARAMS..') ) << "Measurement failure";'
    end
  end
  OUT=OUT..'\n'
end))

} // END FOR EACH TEST
)
