/*=========================================================================
*
*  Copyright Insight Software Consortium
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at sitkImageFilterTestTemplate.cxx.in to make changes.
 */

#include <SimpleITKTestHarness.h>

#include <sitk${name}.h>
#include <sitkImageFileReader.h>
#include <sitkImageFileWriter.h>
#include <sitkHashImageFilter.h>
#include <sitkCastImageFilter.h>
#include <sitkConditional.h>
#include <sitkVersion.h>

namespace {
void * GetBufferAsVoid( itk::simple::Image &sitkImage)
{

  namespace sitk = itk::simple;
  void *sitkBufferPtr = NULL;

  switch( sitkImage.GetPixelIDValue() )
    {
    case sitk::sitkUnknown:
      break;
    case sitk::ConditionalValue< sitk::sitkVectorUInt8 != sitk::sitkUnknown, sitk::sitkVectorUInt8, -14 >::Value:
    case sitk::ConditionalValue< sitk::sitkUInt8 != sitk::sitkUnknown, sitk::sitkUInt8, -2 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsUInt8();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorInt8 != sitk::sitkUnknown, sitk::sitkVectorInt8, -15 >::Value:
    case sitk::ConditionalValue< sitk::sitkInt8 != sitk::sitkUnknown, sitk::sitkInt8, -3 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsInt8();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorUInt16 != sitk::sitkUnknown, sitk::sitkVectorUInt16, -16 >::Value:
    case sitk::ConditionalValue< sitk::sitkUInt16 != sitk::sitkUnknown, sitk::sitkUInt16, -4 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsUInt16();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorInt16 != sitk::sitkUnknown, sitk::sitkVectorInt16, -17 >::Value:
    case sitk::ConditionalValue< sitk::sitkInt16 != sitk::sitkUnknown, sitk::sitkInt16, -5 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsInt16();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorUInt32 != sitk::sitkUnknown, sitk::sitkVectorUInt32, -18 >::Value:
    case sitk::ConditionalValue< sitk::sitkUInt32 != sitk::sitkUnknown, sitk::sitkUInt32, -6 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsUInt32();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorInt32 != sitk::sitkUnknown, sitk::sitkVectorInt32, -19 >::Value:
    case sitk::ConditionalValue< sitk::sitkInt32 != sitk::sitkUnknown, sitk::sitkInt32, -7 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsInt32();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorUInt64 != sitk::sitkUnknown, sitk::sitkVectorUInt64, -20 >::Value:
    case sitk::ConditionalValue< sitk::sitkUInt64 != sitk::sitkUnknown, sitk::sitkUInt64, -8 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsUInt64();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorInt64 != sitk::sitkUnknown, sitk::sitkVectorInt64, -21 >::Value:
    case sitk::ConditionalValue< sitk::sitkInt64 != sitk::sitkUnknown, sitk::sitkInt64, -9 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsInt64();
     break;
    case sitk::ConditionalValue< sitk::sitkVectorFloat32 != sitk::sitkUnknown, sitk::sitkVectorFloat32, -22 >::Value:
    case sitk::ConditionalValue< sitk::sitkFloat32 != sitk::sitkUnknown, sitk::sitkFloat32, -10 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsFloat();
      break;
    case sitk::ConditionalValue< sitk::sitkVectorFloat64 != sitk::sitkUnknown, sitk::sitkVectorFloat64, -23 >::Value:
    case sitk::ConditionalValue< sitk::sitkFloat64 != sitk::sitkUnknown, sitk::sitkFloat64, -11 >::Value:
      sitkBufferPtr = (void *)sitkImage.GetBufferAsDouble();
      break;
    case sitk::ConditionalValue< sitk::sitkComplexFloat32 != sitk::sitkUnknown, sitk::sitkComplexFloat32, -12 >::Value:
      //sitkBufferPtr = (void *)sitkImage.GetBufferAsComplexFloat32();
      break;
    case sitk::ConditionalValue< sitk::sitkComplexFloat64 != sitk::sitkUnknown, sitk::sitkComplexFloat64, -13 >::Value:
      //sitkBufferPtr = (void *)sitkImage.GetBufferAsComplexFloat64();
      break;
      break;
  default:
    ;
    }
  return sitkBufferPtr;
}

}


TEST(BasicFilters,${name}) {
  itk::simple::ImageFileReader reader;
  itk::simple::${name} filter;
  itk::simple::Image inputA( 0, 0, itk::simple::sitkUInt8 );
  itk::simple::Image inputB( 0, 0, itk::simple::sitkUInt8 );
  itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
  std::string inputSHA1hash;

  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing get for ${name}";]]
end)
)
  EXPECT_NE ( filter.ToString(), "" ) << "empty ToString method!";
  EXPECT_EQ ( filter.GetName(), "${name}" ) << "checking GetName method!";

  // Test sets / gets
$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[filter.Set${name} ( ${default} );
  for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing set/get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[filter.Set${name} ( ${default} );
  EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing set/get for ${name}";]]
end)
)

$(if template_type and template_type == "RegionGrowing" then OUT=[[
  // Test size of default SeedList
  EXPECT_EQ ( filter.GetSeedList().size(), (unsigned int)0 ) << "Testing empty seed list as default";]]
end)

$(if template_code_filename and template_code_filename == "FastMarchingImageFilter" then OUT=[[
  // Test size of default TrialPoints
  EXPECT_EQ ( filter.GetTrialPoints().size(), (unsigned int)0 ) << "Testing empty trial points as default";]]
end)

$(if number_of_inputs == 2 then
   OUT=[[ {
  itk::simple::Image smallImage( 1,1,1,itk::simple::sitkUInt8 );
  itk::simple::Image largeImage( 10,10,10,itk::simple::sitkUInt8 );
  itk::simple::Image smallShortImage( 1,1,1,itk::simple::sitkUInt16 );
  try
    {
    // Try executing with different size images.
    // This will either work or throw an exception, either is OK. So
    // this is here just to make sure that the behavior does not cause
    // undefined behavior such as segfault, or other errouneos behavior.
    filter.Execute ( largeImage, smallImage );
    } catch (... )
    { }
]]
  if template_code_filename and template_code_filename == "DualImageFilter" then
    OUT = OUT .. [=[
        // todo add intelligence to determin some image types to test
        //ASSERT_NO_THROW ( filter.Execute ( smallImage, smallShortImage ) ) << " Image types are different";
]=]
  else
    OUT = OUT .. [=[

  ASSERT_THROW ( filter.Execute ( smallImage, smallShortImage ), itk::simple::GenericException ) << " Image types are different"; ]=]
  end
  OUT = OUT .. [[
  }]]
   end)
  // This block is to verify that the input images for named inputs are
  // check if the sizes match for computation.
$(if inputs then
OUT = OUT .. [[
  itk::simple::Image smallImage( 1,1,1,itk::simple::sitkUInt8 );
  itk::simple::Image largeImage( 10,10,10,itk::simple::sitkUInt8 );
]]
    for inum=2,#inputs do
      if  not inputs[inum].optional and not inputs[inum].no_size_check then
        OUT = OUT .. [[
  EXPECT_THROW ( filter.Execute ( largeImage]]
        for jnum=2,#inputs do
         if jnum == inum then
           OUT = OUT .. [[, smallImage]]
         elseif not inputs[jnum].optional then
           OUT = OUT .. [[, largeImage]]
         end
        end
        OUT = OUT .. [[ ), itk::simple::GenericException);
]]
      end
     end

  end)
}

$(foreach tests
TEST(BasicFilters,${name}_${tag})
  { // BEGIN FOR EACH TEST
  /* TAG: ${tag} DESCRIPTION: ${description} */

  itk::simple::ImageFileReader reader;
  itk::simple::${name} filter;
  itk::simple::Image output;
  itk::simple::HashImageFilter hasher;
  std::string inputSHA1hash;

  std::vector<itk::simple::Image> inputs;
  std::vector<std::string> inputFileNames;

$(for inum=1,#inputs do
    OUT=OUT..[[
  inputFileNames.push_back( "]]..inputs[inum]..[["  );
]]
end)

  for ( unsigned int i = 0; i < inputFileNames.size(); ++i )
    {
    ASSERT_NO_THROW ( inputs.push_back( reader.SetFileName ( dataFinder.GetFile ( inputFileNames[i]  ) ).Execute() ) ) << "Failed to load " << inputFileNames[i] << " from " << dataFinder.GetFile ( inputFileNames[i]  );

$(if inputA_cast then
      OUT=[[
      if ( i == 0 )
        {
          ASSERT_NO_THROW( inputs[i]  = itk::simple::Cast( inputs[i], itk::simple::${inputA_cast } ) ) << "Failed to cast inputA to ${inputA_cast}";
        }
]] end)$(if inputB_cast then
      OUT=[[
    if ( i == 1 )
      {
      ASSERT_NO_THROW( inputs[i] = itk::simple::Cast( inputs[i], itk::simple::${inputB_cast } ) ) << "Failed to cast inputB to ${inputB_cast}";
      }
]] end)
    ASSERT_TRUE ( inputs[i].GetITKBase() != NULL ) << "Could not read " << inputFileNames[i];
    }

    if ( !inputs.empty() )
      {
      inputSHA1hash =  itk::simple::Hash( inputs[0] );
      }

  $(if (not no_procedure) or (no_procedure ==0) then
OUT=[=[

      // Do we get the same image back, if we use the functional interface?
      itk::simple::Image fromFunctional( 0, 0, itk::simple::sitkUInt8 );
      itk::simple::Image fromProcedural( 0, 0, itk::simple::sitkUInt8 );
      EXPECT_NO_THROW ( fromProcedural = filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) ) << "Procedural interface to ${name}";
      EXPECT_NO_THROW ( fromFunctional = itk::simple::${name:gsub("ImageFilter$", ""):gsub("Filter$", ""):gsub("ImageSource$", "Source")} ( $(if true then
local count = 0
if #inputs > 0 then
  OUT=[[inputs[0] ]]
  count = count + 1
end
for inum=1,#inputs-1 do
  OUT=OUT..", inputs["..inum.."]"
  count = count + 1
end
if template_type and template_type == "RegionGrowing" then
  OUT=OUT..", std::vector< std::vector<unsigned int> >()"
  count = count + 1
end
if template_code_filename and template_code_filename == "FastMarchingImageFilter" then
  OUT=OUT..", std::vector< std::vector<unsigned int> >()"
  count = count + 1
end
if template_code_filename and template_code_filename == "KernelImageFilter" then
  OUT=OUT..[[, 1, itk::simple::sitkBall]]
  count = count + 1
end
for i = 1,#members do
  if count > 0 then
    OUT = OUT .. ", "
  end
  count = count + 1
  OUT= OUT .. members[i].default
end
end)) ) << "Functional interface to ${name}";
      hasher.SetHashFunction ( itk::simple::HashImageFilter::MD5 );
      EXPECT_EQ ( hasher.Execute ( fromProcedural ), hasher.Execute ( fromFunctional ) ) << "procedural and functional are not the same!";
]=] end)


$(if settings then
OUT=[[
$(foreach settings
  $(if parameter == "SeedList" then
  OUT='filter.ClearSeeds();\
  $(for i=1,#value do OUT=OUT .. "{unsigned int __seed[] = " .. value[i] .. "; filter.AddSeed( std::vector<unsigned int>(__seed, __seed + inputs[0].GetDimension()) );}" end);'
  elseif parameter == "TrialPoints" then
  OUT='filter.ClearTrialPoints();\
  $(for i=1,#value do OUT=OUT .. "{unsigned int __point[] = " .. value[i] .. "; filter.AddTrialPoint( std::vector<unsigned int>(__point, __point + inputs[0].GetDimension()) );}" end);'
  elseif point_vec and point_vec == 1 then
    OUT="filter.Clear${parameter}();"
    for i=1,#value do
      OUT=OUT.. "{unsigned int __point[] = " .. value[i].. ";"
      OUT=OUT.."filter.Add${parameter:gsub('s([0-9]?)$','%1')}( std::vector<unsigned int>(__point, __point + inputs[0].GetDimension()) );}"
     end
  elseif dim_vec and dim_vec == 1 then
  OUT='{\
  ${type} arr[] = {'
  for i=1,#value-1 do
    OUT=OUT..value[i]..", "
  end
  OUT=OUT..value[#value]
  OUT=OUT..'};\
  std::vector< ${type} > vec(arr, arr + sizeof(arr)/sizeof(${type}));\
  filter.Set${parameter} ( vec );\
  for(unsigned int i = 0; i < filter.Get${parameter}().size(); ++i)\
    {\
    ASSERT_EQ ( filter.Get${parameter}()[i], vec[i] ) << "Failed to set ${parameter} to ${value}";\
    }\
  }'
  else
    if cxx_value then
      temp = cxx_value
    else
      temp = value
    end
    OUT='filter.Set${parameter} ( ${temp} );'
      if (not no_get_method) then
        if (temp == "true") then
          OUT = OUT .. '\
  ASSERT_TRUE ( filter.Get${parameter}() ) << "Failed to set ${parameter} to ${temp}";'
        elseif (temp == "false") then
          OUT = OUT .. '\
  ASSERT_FALSE ( filter.Get${parameter}() ) << "Failed to set ${parameter} to ${temp}";'
        else
          OUT = OUT .. '\
  ASSERT_EQ ( ${temp}, filter.Get${parameter}() ) << "Failed to set ${parameter} to ${temp}";'
        end
      end
end)
)]]
end)


   filter.DebugOn();
  ASSERT_NO_THROW ( $(if not no_return_image then OUT=[[output =]] end) filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) );

  if ( !inputs.empty() )
      {
      // Check that the input is not modified
      // This will fail if the filter is being run in-place
      EXPECT_EQ ( inputSHA1hash,  itk::simple::Hash( inputs[0] ) ) << "Input was modified by filter.";

      // Check that the input buffer is different that the output
      // buffer, this does not check complex or label map pixel types.
      if (GetBufferAsVoid(output) != SITK_NULLPTR && GetBufferAsVoid(inputs[0]) != SITK_NULLPTR)
        {
        EXPECT_NE(GetBufferAsVoid(output), GetBufferAsVoid(inputs[0]) ) << "Input buffer was copyied to output!";
        }
      }

  $(if md5hash then
  OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed in ${tag}");]]
  end)
  $(if sha1hash then
  OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed in ${tag}"); ]]
  end) $(if tolerance then
  OUT = [[
 IMAGECOMPAREWITHTOLERANCE ( output, "", ${tolerance} );
  ]]end)
$(when measurements_results
$(for i = 1,#measurements_results do
  PARAMS=''
  if measurements_results[i].parameters then
    for pnum=1,#measurements_results[i].parameters do
    if not pnum == 1 then
        PARAMS=PARAM..','
      end
       PARAMS=PARAMS..' '..measurements_results[i].parameters[pnum]
    end
    PARAMS=PARAMS..' '
  end
  if measurements_results[i].tolerance then
    OUT=OUT..'  EXPECT_NEAR( '..measurements_results[i].value..', filter.Get'..measurements_results[i].name..'('..PARAMS..'), '..measurements_results[i].tolerance..' ) << "Measurement failure";'
  else
    if (measurements_results[i].value == "true") then
      OUT=OUT..'  EXPECT_TRUE( filter.Get'..measurements_results[i].name..'('..PARAMS..') ) << "Measurement failure";'
    elseif (measurements_results[i].value == "false") then
      OUT=OUT..'  EXPECT_FALSE( filter.Get'..measurements_results[i].name..'('..PARAMS..') ) << "Measurement failure"; '
    else
      OUT=OUT..'  EXPECT_EQ( '..measurements_results[i].value..', filter.Get'..measurements_results[i].name..'('..PARAMS..') ) << "Measurement failure";'
    end
  end
  OUT=OUT..'\n'
end))

} // END FOR EACH TEST
)
