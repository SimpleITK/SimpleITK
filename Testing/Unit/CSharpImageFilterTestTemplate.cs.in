/*=========================================================================
*
*  Copyright NumFOCUS
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the Licfense is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at CSharpImageFilterTestTemplate.cs.in to make changes.
 */

// This is C# code to test ${name}
using System;
using System.Collections.Generic;
using itk.simple;

public class Test${name} {

    public static int Main(string[] args) {

        try {

            // Get the right number of inputs
            int num_inputs = 1;
$(if number_of_inputs then
            OUT=[[
            num_inputs = ${number_of_inputs};]]
end)

            // Check the command line arguments
            if ( args.Length < num_inputs + 1 ) {
                Console.WriteLine("Usage: ${name} tag <input(s)> output");
                return 1;
            }

            String tag = args[0];

            // Instantiate objects
            ImageFileReader reader = new ImageFileReader();
            ${name} filter = new ${name}();
			List<Image> inputs = new List<Image>();
$(if #tests == 0 then
            OUT=[[
            // No tests defined => exit with error code
            Console.WriteLine ( "No tests defined!" );
            return 1;]]
end)
            // Run each test
$(foreach tests
            if (tag.Equals( "${tag}" )) {

                // Read image(s)
				for ( int i = 1; i < args.Length-1; i++ ) {
                                  reader.SetFileName( args[i] );
                                  inputs.Add( reader.Execute() );
				}

$(if inputA_cast then
                 OUT=[[
                 CastImageFilter caster = new CastImageFilter();
                 caster.SetOutputPixelType( PixelIDValueEnum.${inputA_cast} );
                 inputs[0] = caster.Execute( inputs[0] );]]
end)

$(if inputB_cast then
                 OUT=[[
                 caster = new CastImageFilter();
                 caster.SetOutputPixelType( PixelIDValueEnum.${inputB_cast} );
                 inputs[1] = caster.Execute( inputs[1] );]]
end)


$(when settings
                // Set parameters
$(foreach settings
$(if parameter == "SeedList" then
                OUT=[[
                filter.ClearSeeds();
$(for i=1,#value do OUT=OUT .. "\
                {\
                VectorUInt32 idx = new VectorUInt32( new uint[] " .. value[i] .. " );\
                filter.AddSeed( idx );\
                }\
" end)]]
elseif parameter == "TrialPoints" then
                OUT=[[
                filter.ClearTrialPoints();
$(for i=1,#value do OUT=OUT .. "\
                {\
                VectorUInt32 idx = new VectorUInt32( new uint[] " .. value[i] .. " );\
                filter.AddTrialPoint( idx );\
                }\
" end)]]
elseif point_vec and point_vec == 1 then
    OUT=[[
                filter.Clear${parameter}();
]]
    for i=1,#value do
      OUT=OUT.. [[
                {
                  VectorUInt32 pt = new VectorUInt32( new uint[] ]] .. value[i] .. [[ );
                  filter.Add${parameter:gsub('s([0-9]?)$','%1')}(pt);
                }
]]
    end
elseif dim_vec == 1 then
  A='{'
  for i=1,#value-1 do
    A=A..value[i]..", "
  end
  A=A..value[#value]
  A=A..'}'
  OUT=[[
    {
  $(if type == "bool" then
      OUT="VectorBool idx = new VectorBool( new bool[] "..A.." );"
  elseif type == "unsigned int" then
      OUT="VectorUInt32 idx = new VectorUInt32( new uint[] "..A.." );"
  elseif type == "int" then
      OUT="VectorInt32 idx = new VectorInt32( new int[] "..A.." );"
  elseif type == "unsigned long" then
      OUT="VectorULong idx = new VectorULong( new ulong[] "..A.." );"
  elseif type == "long" then
      OUT="VectorLong idx = new VectorLong( new long[] "..A.." );"
  elseif type == "unsigned short" then
      OUT="VectorUShort idx = new VectorUShort( new ushort[] "..A.." );"
  elseif type == "short" then
      OUT="VectorShort idx = new VectorShort( new short[] "..A.." );"
  elseif type == "float" then
      OUT="VectorFloat idx = new VectorFloat( new float[] "..A.." );"
  elseif type == "double" then
      OUT="VectorDouble idx = new VectorDouble( new double[] "..A.." );"
  elseif type == "uint8_t" then
      OUT="VectorUInt8 idx = new VectorUInt8( new byte[] "..A.." );"
  elseif type == "uint16_t" then
      OUT="VectorUInt16 idx = new VectorUInt16( new ushort[] "..A.." );"
  elseif type == "uint32_t" then
      OUT="VectorUInt32 idx = new VectorUInt32( new uint[] "..A.." );"
  elseif type == "uint64_t" then
      OUT="VectorUInt64 idx = new VectorUInt64( new ulong[] "..A.." );"
  elseif type == "int8_t" then
      OUT="VectorInt8 idx = new VectorInt8( new sbyte[] "..A.." );"
  elseif type == "int16_t" then
      OUT="VectorInt16 idx = new VectorInt16( new short[] "..A.." );"
  elseif type == "int32_t" then
      OUT="VectorInt32 idx = new VectorInt32( new int[] "..A.." );"
  elseif type == "int64_t" then
      OUT="VectorInt64 idx = new VectorInt64( new long[] "..A.." );"
  end)
  filter.Set${parameter}( idx );
  }]]
else
                OUT=[[
                filter.Set${parameter}( $(if csharp_value then OUT='${csharp_value}' else OUT='${value}' end) );]]
end)
)
)
                // Run the filter
                $(if not no_return_image then OUT=[[Image output = ]] end)filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) );

$(if not no_return_image then
OUT=[[
                PixelIDValueEnum[] labelIDs = { PixelIDValueEnum.sitkLabelUInt8, PixelIDValueEnum.sitkLabelUInt16, PixelIDValueEnum.sitkLabelUInt32, PixelIDValueEnum.sitkLabelUInt64 };
                if (Array.IndexOf(labelIDs, output.GetPixelID()) != -1 )
                {
                  LabelMapToLabelImageFilter toImage = new LabelMapToLabelImageFilter();
                  output = toImage.Execute(output);
                }

                // Write output
                ImageFileWriter writer = new ImageFileWriter();
                writer.UseCompressionOn();
                writer.SetFileName( args[args.Length-1] );
                writer.Execute( output );
]]
end)

            }
)
        } catch (Exception ex) {
            Console.WriteLine( "ERROR: " + ex.ToString() );
            return 1;
        }
        return 0;
    }
}
